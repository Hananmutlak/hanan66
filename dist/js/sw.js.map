{"mappings":"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","sources":["<anon>","src/js/sw.js"],"sourcesContent":["const CACHE_NAME = 'disease-tracker-v1';\nconst urlsToCache = [\n    '/',\n    '/index.html',\n    '/statistics.html',\n    '/map.html',\n    '/prevention.html',\n    '/contact.html',\n    '/news.html',\n    '/src/scss/main.scss',\n    '/src/scss/news.scss',\n    '/src/js/main.js',\n    '/src/js/map.js',\n    '/src/js/news.js',\n    '/src/js/charts.js',\n    '/src/assets/images/hero-bg.jpg',\n    '/src/assets/images/virus1.svg',\n    '/src/assets/images/virus1.png'\n];\n// تثبيت Service Worker وتخزين الملفات المطلوبة\nself.addEventListener('install', (event)=>{\n    event.waitUntil(caches.open(CACHE_NAME).then((cache)=>cache.addAll(urlsToCache)).then(()=>self.skipWaiting()));\n});\n// تنشيط Service Worker وحذف التخزينات القديمة\nself.addEventListener('activate', (event)=>{\n    const cacheWhitelist = [\n        CACHE_NAME\n    ];\n    event.waitUntil(caches.keys().then((cacheNames)=>{\n        return Promise.all(cacheNames.map((cacheName)=>{\n            if (cacheWhitelist.indexOf(cacheName) === -1) return caches.delete(cacheName);\n        }));\n    }).then(()=>self.clients.claim()));\n});\n// استراتيجية التخزين المؤقت: Network First للـ API وCache First للموارد الثابتة\nself.addEventListener('fetch', (event)=>{\n    const requestUrl = new URL(event.request.url);\n    // تعامل خاص مع طلبات API\n    if (event.request.url.includes('newsapi.org') || event.request.url.includes('disease.sh')) // استراتيجية Network First للـ API مع تخزين مؤقت للاستخدام في حالة عدم الاتصال\n    event.respondWith(fetch(event.request).then((response)=>{\n        // نسخ الاستجابة لأننا سنستخدمها مرتين\n        const responseToCache = response.clone();\n        // تخزين الاستجابة في التخزين المؤقت\n        caches.open(CACHE_NAME).then((cache)=>{\n            // تخزين الاستجابة فقط إذا كانت ناجحة\n            if (response.status === 200) {\n                // إضافة رأس لتحديد وقت التخزين\n                const headers = new Headers(responseToCache.headers);\n                headers.append('sw-fetched-on', new Date().toISOString());\n                // إنشاء استجابة جديدة مع الرأس المضاف\n                const responseToStore = new Response(responseToCache.body, {\n                    status: responseToCache.status,\n                    statusText: responseToCache.statusText,\n                    headers: headers\n                });\n                // تخزين الاستجابة مع وقت انتهاء الصلاحية (30 دقيقة)\n                cache.put(event.request, responseToStore);\n            }\n        });\n        return response;\n    }).catch(()=>{\n        // في حالة فشل الاتصال، استخدم النسخة المخزنة مؤقتًا\n        return caches.match(event.request).then((cachedResponse)=>{\n            if (cachedResponse) {\n                // التحقق من عمر البيانات المخزنة\n                const fetchedOn = new Date(cachedResponse.headers.get('sw-fetched-on'));\n                const ageInMinutes = (new Date() - fetchedOn) / 60000;\n                // إذا كانت البيانات أقدم من ساعة، عرض إشعار للمستخدم\n                if (ageInMinutes > 60) // يمكن إضافة رمز هنا لإظهار إشعار للمستخدم بأن البيانات قديمة\n                console.warn('Using cached data that is older than 1 hour');\n                return cachedResponse;\n            }\n            // إذا لم تكن هناك نسخة مخزنة، عرض رسالة خطأ\n            return new Response(JSON.stringify({\n                error: 'You are offline and no cached data is available'\n            }), {\n                status: 503,\n                statusText: 'Service Unavailable',\n                headers: new Headers({\n                    'Content-Type': 'application/json'\n                })\n            });\n        });\n    }));\n    else // استراتيجية Cache First للموارد الثابتة\n    event.respondWith(caches.match(event.request).then((response)=>{\n        // إذا وجدت في التخزين المؤقت، أعد النسخة المخزنة\n        if (response) return response;\n        // إذا لم تكن موجودة في التخزين المؤقت، قم بجلبها من الشبكة\n        return fetch(event.request).then((networkResponse)=>{\n            // تخزين الاستجابة الجديدة في التخزين المؤقت\n            if (networkResponse.status === 200 && networkResponse.type === 'basic') {\n                const responseToCache = networkResponse.clone();\n                caches.open(CACHE_NAME).then((cache)=>{\n                    cache.put(event.request, responseToCache);\n                });\n            }\n            return networkResponse;\n        });\n    }));\n});\n// استراتيجية تحديث التخزين المؤقت في الخلفية\nself.addEventListener('sync', (event)=>{\n    if (event.tag === 'update-cache') event.waitUntil(caches.open(CACHE_NAME).then((cache)=>{\n        return Promise.all(urlsToCache.map((url)=>{\n            return fetch(url).then((response)=>{\n                if (response.status === 200) return cache.put(url, response);\n            }).catch((error)=>console.error('Background sync failed:', error));\n        }));\n    }));\n});\n\n//# sourceMappingURL=sw.js.map\n","const CACHE_NAME = 'disease-tracker-v1';\r\nconst urlsToCache = [\r\n  '/',\r\n  '/index.html',\r\n  '/statistics.html',\r\n  '/map.html',\r\n  '/prevention.html',\r\n  '/contact.html',\r\n  '/news.html',\r\n  '/src/scss/main.scss',\r\n  '/src/scss/news.scss',\r\n  '/src/js/main.js',\r\n  '/src/js/map.js',\r\n  '/src/js/news.js',\r\n  '/src/js/charts.js',\r\n  '/src/assets/images/hero-bg.jpg',\r\n  '/src/assets/images/virus1.svg',\r\n  '/src/assets/images/virus1.png'\r\n];\r\n\r\n// تثبيت Service Worker وتخزين الملفات المطلوبة\r\nself.addEventListener('install', event => {\r\n  event.waitUntil(\r\n    caches.open(CACHE_NAME)\r\n      .then(cache => cache.addAll(urlsToCache))\r\n      .then(() => self.skipWaiting())\r\n  );\r\n});\r\n\r\n// تنشيط Service Worker وحذف التخزينات القديمة\r\nself.addEventListener('activate', event => {\r\n  const cacheWhitelist = [CACHE_NAME];\r\n  event.waitUntil(\r\n    caches.keys().then(cacheNames => {\r\n      return Promise.all(\r\n        cacheNames.map(cacheName => {\r\n          if (cacheWhitelist.indexOf(cacheName) === -1) {\r\n            return caches.delete(cacheName);\r\n          }\r\n        })\r\n      );\r\n    }).then(() => self.clients.claim())\r\n  );\r\n});\r\n\r\n// استراتيجية التخزين المؤقت: Network First للـ API وCache First للموارد الثابتة\r\nself.addEventListener('fetch', event => {\r\n  const requestUrl = new URL(event.request.url);\r\n  \r\n  // تعامل خاص مع طلبات API\r\n  if (\r\n    event.request.url.includes('newsapi.org') || \r\n    event.request.url.includes('disease.sh')\r\n  ) {\r\n    // استراتيجية Network First للـ API مع تخزين مؤقت للاستخدام في حالة عدم الاتصال\r\n    event.respondWith(\r\n      fetch(event.request)\r\n        .then(response => {\r\n          // نسخ الاستجابة لأننا سنستخدمها مرتين\r\n          const responseToCache = response.clone();\r\n          \r\n          // تخزين الاستجابة في التخزين المؤقت\r\n          caches.open(CACHE_NAME)\r\n            .then(cache => {\r\n              // تخزين الاستجابة فقط إذا كانت ناجحة\r\n              if (response.status === 200) {\r\n                // إضافة رأس لتحديد وقت التخزين\r\n                const headers = new Headers(responseToCache.headers);\r\n                headers.append('sw-fetched-on', new Date().toISOString());\r\n                \r\n                // إنشاء استجابة جديدة مع الرأس المضاف\r\n                const responseToStore = new Response(\r\n                  responseToCache.body, \r\n                  {\r\n                    status: responseToCache.status,\r\n                    statusText: responseToCache.statusText,\r\n                    headers: headers\r\n                  }\r\n                );\r\n                \r\n                // تخزين الاستجابة مع وقت انتهاء الصلاحية (30 دقيقة)\r\n                cache.put(event.request, responseToStore);\r\n              }\r\n            });\r\n          \r\n          return response;\r\n        })\r\n        .catch(() => {\r\n          // في حالة فشل الاتصال، استخدم النسخة المخزنة مؤقتًا\r\n          return caches.match(event.request)\r\n            .then(cachedResponse => {\r\n              if (cachedResponse) {\r\n                // التحقق من عمر البيانات المخزنة\r\n                const fetchedOn = new Date(cachedResponse.headers.get('sw-fetched-on'));\r\n                const ageInMinutes = (new Date() - fetchedOn) / (1000 * 60);\r\n                \r\n                // إذا كانت البيانات أقدم من ساعة، عرض إشعار للمستخدم\r\n                if (ageInMinutes > 60) {\r\n                  // يمكن إضافة رمز هنا لإظهار إشعار للمستخدم بأن البيانات قديمة\r\n                  console.warn('Using cached data that is older than 1 hour');\r\n                }\r\n                \r\n                return cachedResponse;\r\n              }\r\n              \r\n              // إذا لم تكن هناك نسخة مخزنة، عرض رسالة خطأ\r\n              return new Response(\r\n                JSON.stringify({ \r\n                  error: 'You are offline and no cached data is available' \r\n                }),\r\n                { \r\n                  status: 503,\r\n                  statusText: 'Service Unavailable',\r\n                  headers: new Headers({ 'Content-Type': 'application/json' })\r\n                }\r\n              );\r\n            });\r\n        })\r\n    );\r\n  } else {\r\n    // استراتيجية Cache First للموارد الثابتة\r\n    event.respondWith(\r\n      caches.match(event.request)\r\n        .then(response => {\r\n          // إذا وجدت في التخزين المؤقت، أعد النسخة المخزنة\r\n          if (response) {\r\n            return response;\r\n          }\r\n          \r\n          // إذا لم تكن موجودة في التخزين المؤقت، قم بجلبها من الشبكة\r\n          return fetch(event.request)\r\n            .then(networkResponse => {\r\n              // تخزين الاستجابة الجديدة في التخزين المؤقت\r\n              if (networkResponse.status === 200 && networkResponse.type === 'basic') {\r\n                const responseToCache = networkResponse.clone();\r\n                caches.open(CACHE_NAME)\r\n                  .then(cache => {\r\n                    cache.put(event.request, responseToCache);\r\n                  });\r\n              }\r\n              \r\n              return networkResponse;\r\n            });\r\n        })\r\n    );\r\n  }\r\n});\r\n\r\n// استراتيجية تحديث التخزين المؤقت في الخلفية\r\nself.addEventListener('sync', event => {\r\n  if (event.tag === 'update-cache') {\r\n    event.waitUntil(\r\n      caches.open(CACHE_NAME)\r\n        .then(cache => {\r\n          return Promise.all(\r\n            urlsToCache.map(url => {\r\n              return fetch(url)\r\n                .then(response => {\r\n                  if (response.status === 200) {\r\n                    return cache.put(url, response);\r\n                  }\r\n                })\r\n                .catch(error => console.error('Background sync failed:', error));\r\n            })\r\n          );\r\n        })\r\n    );\r\n  }\r\n});\r\n"],"names":["CACHE_NAME","urlsToCache","self","addEventListener","event","waitUntil","caches","open","then","cache","addAll","skipWaiting","cacheWhitelist","keys","cacheNames","Promise","all","map","cacheName","indexOf","delete","clients","claim","URL","request","url","includes","respondWith","fetch","response","responseToCache","clone","status","headers","Headers","append","Date","toISOString","responseToStore","Response","body","statusText","put","catch","match","cachedResponse","fetchedOn","get","console","warn","JSON","stringify","error","networkResponse","type","tag"],"version":3,"file":"sw.js.map"}