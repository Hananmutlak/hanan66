{"mappings":"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","sources":["<anon>","src/js/sw.js"],"sourcesContent":["const CACHE_NAME = 'disease-tracker-v1';\nconst urlsToCache = [\n    '/',\n    '/index.html',\n    '/statistics.html',\n    '/map.html',\n    '/prevention.html',\n    '/contact.html',\n    '/news.html',\n    '/src/scss/main.scss',\n    '/src/scss/news.scss',\n    '/src/js/main.js',\n    '/src/js/map.js',\n    '/src/js/news.js',\n    '/src/js/charts.js',\n    '/src/assets/images/hero-bg.jpg',\n    '/src/assets/images/virus1.svg',\n    '/src/assets/images/virus1.png'\n];\n// تثبيت Service Worker وتخزين الملفات المطلوبة\nself.addEventListener('install', (event)=>{\n    event.waitUntil(caches.open(CACHE_NAME).then((cache)=>cache.addAll(urlsToCache)).then(()=>self.skipWaiting()));\n});\n// تنشيط Service Worker وحذف التخزينات القديمة\nself.addEventListener('activate', (event)=>{\n    const cacheWhitelist = [\n        CACHE_NAME\n    ];\n    event.waitUntil(caches.keys().then((cacheNames)=>{\n        return Promise.all(cacheNames.map((cacheName)=>{\n            if (cacheWhitelist.indexOf(cacheName) === -1) return caches.delete(cacheName);\n        }));\n    }).then(()=>self.clients.claim()));\n});\n// استراتيجية التخزين المؤقت: Network First للـ API وCache First للموارد الثابتة\nself.addEventListener('fetch', (event)=>{\n    const requestUrl = new URL(event.request.url);\n    // تعامل خاص مع طلبات API\n    if (event.request.url.includes('newsapi.org') || event.request.url.includes('disease.sh')) // استراتيجية Network First للـ API مع تخزين مؤقت للاستخدام في حالة عدم الاتصال\n    event.respondWith(fetch(event.request).then((response)=>{\n        // نسخ الاستجابة لأننا سنستخدمها مرتين\n        const responseToCache = response.clone();\n        // تخزين الاستجابة في التخزين المؤقت\n        caches.open(CACHE_NAME).then((cache)=>{\n            // تخزين الاستجابة فقط إذا كانت ناجحة\n            if (response.status === 200) {\n                // إضافة رأس لتحديد وقت التخزين\n                const headers = new Headers(responseToCache.headers);\n                headers.append('sw-fetched-on', new Date().toISOString());\n                // إنشاء استجابة جديدة مع الرأس المضاف\n                const responseToStore = new Response(responseToCache.body, {\n                    status: responseToCache.status,\n                    statusText: responseToCache.statusText,\n                    headers: headers\n                });\n                // تخزين الاستجابة مع وقت انتهاء الصلاحية (30 دقيقة)\n                cache.put(event.request, responseToStore);\n            }\n        });\n        return response;\n    }).catch(()=>{\n        // في حالة فشل الاتصال، استخدم النسخة المخزنة مؤقتًا\n        return caches.match(event.request).then((cachedResponse)=>{\n            if (cachedResponse) {\n                // التحقق من عمر البيانات المخزنة\n                const fetchedOn = new Date(cachedResponse.headers.get('sw-fetched-on'));\n                const ageInMinutes = (new Date() - fetchedOn) / 60000;\n                // إذا كانت البيانات أقدم من ساعة، عرض إشعار للمستخدم\n                if (ageInMinutes > 60) // يمكن إضافة رمز هنا لإظهار إشعار للمستخدم بأن البيانات قديمة\n                console.warn('Using cached data that is older than 1 hour');\n                return cachedResponse;\n            }\n            // إذا لم تكن هناك نسخة مخزنة، عرض رسالة خطأ\n            return new Response(JSON.stringify({\n                error: 'You are offline and no cached data is available'\n            }), {\n                status: 503,\n                statusText: 'Service Unavailable',\n                headers: new Headers({\n                    'Content-Type': 'application/json'\n                })\n            });\n        });\n    }));\n    else // استراتيجية Cache First للموارد الثابتة\n    event.respondWith(caches.match(event.request).then((response)=>{\n        // إذا وجدت في التخزين المؤقت، أعد النسخة المخزنة\n        if (response) return response;\n        // إذا لم تكن موجودة في التخزين المؤقت، قم بجلبها من الشبكة\n        return fetch(event.request).then((networkResponse)=>{\n            // تخزين الاستجابة الجديدة في التخزين المؤقت\n            if (networkResponse.status === 200 && networkResponse.type === 'basic') {\n                const responseToCache = networkResponse.clone();\n                caches.open(CACHE_NAME).then((cache)=>{\n                    cache.put(event.request, responseToCache);\n                });\n            }\n            return networkResponse;\n        });\n    }));\n});\n// استراتيجية تحديث التخزين المؤقت في الخلفية\nself.addEventListener('sync', (event)=>{\n    if (event.tag === 'update-cache') event.waitUntil(caches.open(CACHE_NAME).then((cache)=>{\n        return Promise.all(urlsToCache.map((url)=>{\n            return fetch(url).then((response)=>{\n                if (response.status === 200) return cache.put(url, response);\n            }).catch((error)=>console.error('Background sync failed:', error));\n        }));\n    }));\n});\n\n//# sourceMappingURL=sw.js.map\n","const CACHE_NAME = 'disease-tracker-v1';\nconst urlsToCache = [\n  '/',\n  '/index.html',\n  '/statistics.html',\n  '/map.html',\n  '/prevention.html',\n  '/contact.html',\n  '/news.html',\n  '/src/scss/main.scss',\n  '/src/scss/news.scss',\n  '/src/js/main.js',\n  '/src/js/map.js',\n  '/src/js/news.js',\n  '/src/js/charts.js',\n  '/src/assets/images/hero-bg.jpg',\n  '/src/assets/images/virus1.svg',\n  '/src/assets/images/virus1.png'\n];\n\n// تثبيت Service Worker وتخزين الملفات المطلوبة\nself.addEventListener('install', event => {\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then(cache => cache.addAll(urlsToCache))\n      .then(() => self.skipWaiting())\n  );\n});\n\n// تنشيط Service Worker وحذف التخزينات القديمة\nself.addEventListener('activate', event => {\n  const cacheWhitelist = [CACHE_NAME];\n  event.waitUntil(\n    caches.keys().then(cacheNames => {\n      return Promise.all(\n        cacheNames.map(cacheName => {\n          if (cacheWhitelist.indexOf(cacheName) === -1) {\n            return caches.delete(cacheName);\n          }\n        })\n      );\n    }).then(() => self.clients.claim())\n  );\n});\n\n// استراتيجية التخزين المؤقت: Network First للـ API وCache First للموارد الثابتة\nself.addEventListener('fetch', event => {\n  const requestUrl = new URL(event.request.url);\n  \n  // تعامل خاص مع طلبات API\n  if (\n    event.request.url.includes('newsapi.org') || \n    event.request.url.includes('disease.sh')\n  ) {\n    // استراتيجية Network First للـ API مع تخزين مؤقت للاستخدام في حالة عدم الاتصال\n    event.respondWith(\n      fetch(event.request)\n        .then(response => {\n          // نسخ الاستجابة لأننا سنستخدمها مرتين\n          const responseToCache = response.clone();\n          \n          // تخزين الاستجابة في التخزين المؤقت\n          caches.open(CACHE_NAME)\n            .then(cache => {\n              // تخزين الاستجابة فقط إذا كانت ناجحة\n              if (response.status === 200) {\n                // إضافة رأس لتحديد وقت التخزين\n                const headers = new Headers(responseToCache.headers);\n                headers.append('sw-fetched-on', new Date().toISOString());\n                \n                // إنشاء استجابة جديدة مع الرأس المضاف\n                const responseToStore = new Response(\n                  responseToCache.body, \n                  {\n                    status: responseToCache.status,\n                    statusText: responseToCache.statusText,\n                    headers: headers\n                  }\n                );\n                \n                // تخزين الاستجابة مع وقت انتهاء الصلاحية (30 دقيقة)\n                cache.put(event.request, responseToStore);\n              }\n            });\n          \n          return response;\n        })\n        .catch(() => {\n          // في حالة فشل الاتصال، استخدم النسخة المخزنة مؤقتًا\n          return caches.match(event.request)\n            .then(cachedResponse => {\n              if (cachedResponse) {\n                // التحقق من عمر البيانات المخزنة\n                const fetchedOn = new Date(cachedResponse.headers.get('sw-fetched-on'));\n                const ageInMinutes = (new Date() - fetchedOn) / (1000 * 60);\n                \n                // إذا كانت البيانات أقدم من ساعة، عرض إشعار للمستخدم\n                if (ageInMinutes > 60) {\n                  // يمكن إضافة رمز هنا لإظهار إشعار للمستخدم بأن البيانات قديمة\n                  console.warn('Using cached data that is older than 1 hour');\n                }\n                \n                return cachedResponse;\n              }\n              \n              // إذا لم تكن هناك نسخة مخزنة، عرض رسالة خطأ\n              return new Response(\n                JSON.stringify({ \n                  error: 'You are offline and no cached data is available' \n                }),\n                { \n                  status: 503,\n                  statusText: 'Service Unavailable',\n                  headers: new Headers({ 'Content-Type': 'application/json' })\n                }\n              );\n            });\n        })\n    );\n  } else {\n    // استراتيجية Cache First للموارد الثابتة\n    event.respondWith(\n      caches.match(event.request)\n        .then(response => {\n          // إذا وجدت في التخزين المؤقت، أعد النسخة المخزنة\n          if (response) {\n            return response;\n          }\n          \n          // إذا لم تكن موجودة في التخزين المؤقت، قم بجلبها من الشبكة\n          return fetch(event.request)\n            .then(networkResponse => {\n              // تخزين الاستجابة الجديدة في التخزين المؤقت\n              if (networkResponse.status === 200 && networkResponse.type === 'basic') {\n                const responseToCache = networkResponse.clone();\n                caches.open(CACHE_NAME)\n                  .then(cache => {\n                    cache.put(event.request, responseToCache);\n                  });\n              }\n              \n              return networkResponse;\n            });\n        })\n    );\n  }\n});\n\n// استراتيجية تحديث التخزين المؤقت في الخلفية\nself.addEventListener('sync', event => {\n  if (event.tag === 'update-cache') {\n    event.waitUntil(\n      caches.open(CACHE_NAME)\n        .then(cache => {\n          return Promise.all(\n            urlsToCache.map(url => {\n              return fetch(url)\n                .then(response => {\n                  if (response.status === 200) {\n                    return cache.put(url, response);\n                  }\n                })\n                .catch(error => console.error('Background sync failed:', error));\n            })\n          );\n        })\n    );\n  }\n});\n"],"names":["CACHE_NAME","urlsToCache","self","addEventListener","event","waitUntil","caches","open","then","cache","addAll","skipWaiting","cacheWhitelist","keys","cacheNames","Promise","all","map","cacheName","indexOf","delete","clients","claim","URL","request","url","includes","respondWith","fetch","response","responseToCache","clone","status","headers","Headers","append","Date","toISOString","responseToStore","Response","body","statusText","put","catch","match","cachedResponse","fetchedOn","get","console","warn","JSON","stringify","error","networkResponse","type","tag"],"version":3,"file":"sw.js.map"}