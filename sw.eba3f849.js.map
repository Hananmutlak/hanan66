{"mappings":"C,A,S,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,E,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,A,Y,O,C,C,E,E,C,C,E,C,E,E,C,E,C,E,E,E,K,E,C,E,E,A,a,O,Q,A,Y,O,O,O,E,O,O,C,I,C,Q,S,E,C,C,C,E,G,C,C,C,E,C,C,G,C,C,C,E,C,C,G,C,C,E,C,O,C,C,E,C,I,E,A,Y,O,C,C,E,E,C,C,E,C,G,C,G,E,O,E,E,C,G,G,E,O,E,E,C,G,G,G,A,U,O,E,O,E,G,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,O,C,S,C,E,I,E,C,C,E,C,E,C,E,C,O,A,M,E,E,C,E,E,K,C,C,E,I,E,C,C,E,C,I,E,M,C,G,C,C,E,C,E,C,I,C,E,O,C,E,E,E,O,C,E,C,O,C,C,E,C,O,C,S,E,C,E,I,E,E,O,C,G,M,A,C,I,E,C,E,E,E,C,C,E,e,C,C,E,E,M,C,S,C,E,I,C,E,C,E,I,C,M,C,E,I,C,O,C,E,I,C,O,C,C,C,E,E,O,C,E,E,K,C,E,E,M,C,E,E,O,C,K,E,E,S,C,K,E,E,S,C,K,E,E,C,C,E,E,Q,C,S,C,C,C,E,C,C,E,C,C,S,C,C,C,E,E,O,C,C,E,C,E,A,E,O,c,C,E,O,C,I,W,O,C,C,E,A,C,G,C,C,E,C,E,I,I,E,E,E,E,M,C,I,E,C,C,E,E,G,E,C,I,E,E,E,A,C,U,O,S,A,a,O,O,O,O,C,E,Y,O,Q,O,G,E,O,W,O,C,E,C,E,C,Q,C,S,C,C,C,C,C,C,C,ECCA,IAAM,EAAO,WAAW,IAAI,CACtB,EAAa,mBACb,EAAiB,iBAGjB,EAAa,CACjB,KACA,eACA,oBACA,aACA,oBACA,iBACA,cACA,iBACA,eACA,cACA,eACA,iBACA,8BACA,6BACA,6BACA,uCACD,CAmFD,eAAe,EAAiB,CAAO,EACrC,GAAI,CAEF,IAAM,EAAgB,EAAQ,GAAG,CAAC,UAAU,CAAC,SAC3C,IAAI,QAAQ,EAAQ,GAAG,CAAC,OAAO,CAAC,UAAW,YAAa,GACxD,EAEI,EAAW,MAAM,MAAM,GAE7B,GAAI,EAAS,EAAE,CAAE,CACf,IAAM,EAAQ,MAAM,OAAO,IAAI,CAAC,EAChC,OAAM,EAAM,GAAG,CAAC,EAAS,EAAS,KAAK,GACzC,CACA,OAAO,CACT,CAAE,MAAO,EAAK,CAGZ,OAFA,QAAQ,KAAK,CAAC,2BAA4B,GAEnC,AADQ,MAAM,OAAO,KAAK,CAAC,IA4B7B,IAAI,SACT,KAAK,SAAS,CAAC,CAAE,MAAO,eAAgB,GACxC,CAAE,OAAQ,IAAK,QAAS,CAAE,eAAgB,kBAAmB,CAAC,EA5BhE,CACF,CAEA,eAAe,EAAc,CAAO,EAClC,GAAI,CACF,IAAM,EAAW,MAAM,MAAM,GAC7B,GAAI,EAAS,EAAE,CAAE,CACf,IAAM,EAAQ,MAAM,OAAO,IAAI,CAAC,EAChC,OAAM,EAAM,GAAG,CAAC,EAAS,EAAS,KAAK,GACzC,CACA,OAAO,CACT,CAAE,MAAO,EAAK,CAEZ,MADA,QAAQ,KAAK,CAAC,qBAAsB,GAC9B,CACR,CACF,CAjHA,EAAK,gBAAgB,CAAC,UAAW,AAAA,IAC/B,EAAM,SAAS,CACb,OAAO,IAAI,CAAC,GACT,IAAI,CAAC,AAAA,IACJ,QAAQ,GAAG,CAAC,0BAmBL,QAAQ,GAAG,CAlBI,EAAW,GAAG,CAAC,AAAA,GAC5B,MAAM,IAAI,QAAQ,EAAK,CAC5B,YAAa,cACb,SAAU,SACV,KAAM,SACR,IACC,IAAI,CAAC,AAAA,GACJ,AAAI,EAAS,EAAE,EAAI,AAAkB,WAAlB,EAAS,IAAI,CACvB,EAAM,GAAG,CAAC,EAAK,IAExB,QAAQ,IAAI,CAAC,CAAC,qBAAqB,EAAE,EAAA,CAAK,EACnC,QAAQ,OAAO,KAEvB,KAAK,CAAC,AAAA,IACL,QAAQ,IAAI,CAAC,CAAC,cAAc,EAAE,EAAI,CAAC,CAAC,CAAE,GAC/B,QAAQ,OAAO,SAK3B,IAAI,CAAC,KACJ,QAAQ,GAAG,CAAC,qBACL,EAAK,WAAW,KAG/B,GAGA,EAAK,gBAAgB,CAAC,WAAY,AAAA,IAChC,EAAM,SAAS,CACb,OAAO,IAAI,GAAG,IAAI,CAAC,AAAA,GACV,QAAQ,GAAG,CAChB,EACG,MAAM,CAAC,AAAA,GAAQ,IAAS,GAAc,IAAS,GAC/C,GAAG,CAAC,AAAA,IACH,QAAQ,GAAG,CAAC,CAAC,yBAAyB,EAAE,EAAA,CAAM,EACvC,OAAO,MAAM,CAAC,OAI5B,IAAI,CAAC,KACJ,QAAQ,GAAG,CAAC,yBACL,EAAK,OAAO,CAAC,KAAK,KAG/B,GAGA,EAAK,gBAAgB,CAAC,QAAS,AAAA,IAC7B,IAAM,EAAU,EAAM,OAAO,CAG7B,GAAI,AAAmB,QAAnB,EAAQ,MAAM,MAiBE,EAdpB,GAeO,CADa,EAdH,GAeF,GAAG,CAAC,QAAQ,CAAC,gBACrB,EAAQ,GAAG,CAAC,QAAQ,CAAC,eACrB,EAAQ,GAAG,CAAC,QAAQ,CAAC,YAjBD,CACzB,EAAM,WAAW,CAAC,EAAiB,IACnC,MACF,CAGA,EAAM,WAAW,CACf,OAAO,KAAK,CAAC,GACV,IAAI,CAAC,AAAA,GAAU,GAAU,EAAc,IACvC,KAAK,CAAC,IA+CX,AAAI,AAAiB,aAAjB,AA/C8B,EA+CtB,IAAI,CACP,OAAO,KAAK,CA3IH,mBAyJX,IAAI,SACT,mDACA,CAAE,QAAS,CAAE,eAAgB,WAAY,CAAC,GAKrC,IAAI,SAAS,UAAW,CAAE,OAAQ,GAAI,KAnE/C,GAuEA,EAAK,gBAAgB,CAAC,UAAW,AAAA,IACZ,gBAAf,EAAM,IAAI,GACZ,QAAQ,GAAG,CAAC,yBACZ,EAAK,WAAW,GAEpB,E,E,C,E,E,C,Q,C,Q,oB,C","sources":["<anon>","src/js/sw.js"],"sourcesContent":["// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\n\n(function (\n  modules,\n  entry,\n  mainEntry,\n  parcelRequireName,\n  externals,\n  distDir,\n  publicUrl,\n  devServer\n) {\n  /* eslint-disable no-undef */\n  var globalObject =\n    typeof globalThis !== 'undefined'\n      ? globalThis\n      : typeof self !== 'undefined'\n      ? self\n      : typeof window !== 'undefined'\n      ? window\n      : typeof global !== 'undefined'\n      ? global\n      : {};\n  /* eslint-enable no-undef */\n\n  // Save the require from previous bundle to this closure if any\n  var previousRequire =\n    typeof globalObject[parcelRequireName] === 'function' &&\n    globalObject[parcelRequireName];\n\n  var importMap = previousRequire.i || {};\n  var cache = previousRequire.cache || {};\n  // Do not use `require` to prevent Webpack from trying to bundle this call\n  var nodeRequire =\n    typeof module !== 'undefined' &&\n    typeof module.require === 'function' &&\n    module.require.bind(module);\n\n  function newRequire(name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        if (externals[name]) {\n          return externals[name];\n        }\n        // if we cannot find the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire =\n          typeof globalObject[parcelRequireName] === 'function' &&\n          globalObject[parcelRequireName];\n        if (!jumped && currentRequire) {\n          return currentRequire(name, true);\n        }\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) {\n          return previousRequire(name, true);\n        }\n\n        // Try the node require function if it exists.\n        if (nodeRequire && typeof name === 'string') {\n          return nodeRequire(name);\n        }\n\n        var err = new Error(\"Cannot find module '\" + name + \"'\");\n        err.code = 'MODULE_NOT_FOUND';\n        throw err;\n      }\n\n      localRequire.resolve = resolve;\n      localRequire.cache = {};\n\n      var module = (cache[name] = new newRequire.Module(name));\n\n      modules[name][0].call(\n        module.exports,\n        localRequire,\n        module,\n        module.exports,\n        globalObject\n      );\n    }\n\n    return cache[name].exports;\n\n    function localRequire(x) {\n      var res = localRequire.resolve(x);\n      return res === false ? {} : newRequire(res);\n    }\n\n    function resolve(x) {\n      var id = modules[name][1][x];\n      return id != null ? id : x;\n    }\n  }\n\n  function Module(moduleName) {\n    this.id = moduleName;\n    this.bundle = newRequire;\n    this.require = nodeRequire;\n    this.exports = {};\n  }\n\n  newRequire.isParcelRequire = true;\n  newRequire.Module = Module;\n  newRequire.modules = modules;\n  newRequire.cache = cache;\n  newRequire.parent = previousRequire;\n  newRequire.distDir = distDir;\n  newRequire.publicUrl = publicUrl;\n  newRequire.devServer = devServer;\n  newRequire.i = importMap;\n  newRequire.register = function (id, exports) {\n    modules[id] = [\n      function (require, module) {\n        module.exports = exports;\n      },\n      {},\n    ];\n  };\n\n  // Only insert newRequire.load when it is actually used.\n  // The code in this file is linted against ES5, so dynamic import is not allowed.\n  // INSERT_LOAD_HERE\n\n  Object.defineProperty(newRequire, 'root', {\n    get: function () {\n      return globalObject[parcelRequireName];\n    },\n  });\n\n  globalObject[parcelRequireName] = newRequire;\n\n  for (var i = 0; i < entry.length; i++) {\n    newRequire(entry[i]);\n  }\n\n  if (mainEntry) {\n    // Expose entry point to Node, AMD or browser globals\n    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js\n    var mainExports = newRequire(mainEntry);\n\n    // CommonJS\n    if (typeof exports === 'object' && typeof module !== 'undefined') {\n      module.exports = mainExports;\n\n      // RequireJS\n    } else if (typeof define === 'function' && define.amd) {\n      define(function () {\n        return mainExports;\n      });\n    }\n  }\n})({\"4ol4K\":[function(require,module,exports,__globalThis) {\n/// <reference lib=\"WebWorker\" />\nconst self = globalThis.self;\nconst CACHE_NAME = 'hanan66-final-v3';\nconst API_CACHE_NAME = 'hanan66-api-v1';\nconst OFFLINE_URL = './offline.html';\nconst CACHE_URLS = [\n    './',\n    './index.html',\n    './statistics.html',\n    './map.html',\n    './prevention.html',\n    './contact.html',\n    './news.html',\n    './css/main.css',\n    './js/main.js',\n    './js/map.js',\n    './js/news.js',\n    './js/charts.js',\n    './assets/images/hero-bg.jpg',\n    './assets/images/virus1.svg',\n    './assets/images/virus1.png',\n    './assets/images/news-placeholder.jpg'\n];\n// ===== التثبيت =====\nself.addEventListener('install', (event)=>{\n    event.waitUntil(caches.open(CACHE_NAME).then((cache)=>{\n        console.log('[SW] Caching app shell');\n        const cachePromises = CACHE_URLS.map((url)=>{\n            return fetch(new Request(url, {\n                credentials: 'same-origin',\n                redirect: 'follow',\n                mode: 'no-cors'\n            })).then((response)=>{\n                if (response.ok || response.type === 'opaque') return cache.put(url, response);\n                console.warn(`[SW] Failed to cache ${url}`);\n                return Promise.resolve();\n            }).catch((err)=>{\n                console.warn(`[SW] Skipping ${url}:`, err);\n                return Promise.resolve();\n            });\n        });\n        return Promise.all(cachePromises);\n    }).then(()=>{\n        console.log('[SW] Skip waiting');\n        return self.skipWaiting();\n    }));\n});\n// ===== التنشيط =====\nself.addEventListener('activate', (event)=>{\n    event.waitUntil(caches.keys().then((cacheNames)=>{\n        return Promise.all(cacheNames.filter((name)=>name !== CACHE_NAME && name !== API_CACHE_NAME).map((name)=>{\n            console.log(`[SW] Deleting old cache: ${name}`);\n            return caches.delete(name);\n        }));\n    }).then(()=>{\n        console.log('[SW] Claiming clients');\n        return self.clients.claim();\n    }));\n});\n// ===== معالجة الطلبات =====\nself.addEventListener('fetch', (event)=>{\n    const request = event.request;\n    // تخطي طلبات غير GET\n    if (request.method !== 'GET') return;\n    // معالجة طلبات API\n    if (isApiRequest(request)) {\n        event.respondWith(handleApiRequest(request));\n        return;\n    }\n    // معالجة الملفات الثابتة\n    event.respondWith(caches.match(request).then((cached)=>cached || fetchAndCache(request)).catch(()=>fallbackResponse(request)));\n});\n// ===== دوال مساعدة =====\nfunction isApiRequest(request) {\n    return request.url.includes('newsapi.org') || request.url.includes('disease.sh') || request.url.includes('gnews.io');\n}\nasync function handleApiRequest(request) {\n    try {\n        // تحويل HTTP إلى HTTPS\n        const secureRequest = request.url.startsWith('http:') ? new Request(request.url.replace('http://', 'https://'), request) : request;\n        const response = await fetch(secureRequest);\n        if (response.ok) {\n            const cache = await caches.open(API_CACHE_NAME);\n            await cache.put(request, response.clone());\n        }\n        return response;\n    } catch (err) {\n        console.error('[SW] API request failed:', err);\n        const cached = await caches.match(request);\n        return cached || apiErrorResponse();\n    }\n}\nasync function fetchAndCache(request) {\n    try {\n        const response = await fetch(request);\n        if (response.ok) {\n            const cache = await caches.open(CACHE_NAME);\n            await cache.put(request, response.clone());\n        }\n        return response;\n    } catch (err) {\n        console.error('[SW] Fetch failed:', err);\n        throw err;\n    }\n}\nfunction fallbackResponse(request) {\n    if (request.mode === 'navigate') return caches.match(OFFLINE_URL) || offlinePageResponse();\n    return offlineDataResponse();\n}\nfunction apiErrorResponse() {\n    return new Response(JSON.stringify({\n        error: 'Network error'\n    }), {\n        status: 503,\n        headers: {\n            'Content-Type': 'application/json'\n        }\n    });\n}\nfunction offlinePageResponse() {\n    return new Response('<h1>Offline</h1><p>You are currently offline</p>', {\n        headers: {\n            'Content-Type': 'text/html'\n        }\n    });\n}\nfunction offlineDataResponse() {\n    return new Response('Offline', {\n        status: 503\n    });\n}\n// ===== معالجة الرسائل =====\nself.addEventListener('message', (event)=>{\n    if (event.data === 'skipWaiting') {\n        console.log('[SW] Skipping waiting');\n        self.skipWaiting();\n    }\n});\n\n},{}]},[\"4ol4K\"], \"4ol4K\", \"parcelRequire5828\", {})\n\n//# sourceMappingURL=sw.eba3f849.js.map\n","/// <reference lib=\"WebWorker\" />\nconst self = globalThis.self;\nconst CACHE_NAME = 'hanan66-final-v3';\nconst API_CACHE_NAME = 'hanan66-api-v1';\nconst OFFLINE_URL = './offline.html';\n\nconst CACHE_URLS = [\n  './',\n  './index.html',\n  './statistics.html',\n  './map.html',\n  './prevention.html',\n  './contact.html',\n  './news.html',\n  './css/main.css',\n  './js/main.js',\n  './js/map.js',\n  './js/news.js',\n  './js/charts.js',\n  './assets/images/hero-bg.jpg',\n  './assets/images/virus1.svg',\n  './assets/images/virus1.png',\n  './assets/images/news-placeholder.jpg'\n];\n\n// ===== التثبيت =====\nself.addEventListener('install', event => {\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then(cache => {\n        console.log('[SW] Caching app shell');\n        const cachePromises = CACHE_URLS.map(url => {\n          return fetch(new Request(url, {\n            credentials: 'same-origin',\n            redirect: 'follow',\n            mode: 'no-cors'\n          }))\n          .then(response => {\n            if (response.ok || response.type === 'opaque') {\n              return cache.put(url, response);\n            }\n            console.warn(`[SW] Failed to cache ${url}`);\n            return Promise.resolve();\n          })\n          .catch(err => {\n            console.warn(`[SW] Skipping ${url}:`, err);\n            return Promise.resolve();\n          });\n        });\n        return Promise.all(cachePromises);\n      })\n      .then(() => {\n        console.log('[SW] Skip waiting');\n        return self.skipWaiting();\n      })\n  );\n});\n\n// ===== التنشيط =====\nself.addEventListener('activate', event => {\n  event.waitUntil(\n    caches.keys().then(cacheNames => {\n      return Promise.all(\n        cacheNames\n          .filter(name => name !== CACHE_NAME && name !== API_CACHE_NAME)\n          .map(name => {\n            console.log(`[SW] Deleting old cache: ${name}`);\n            return caches.delete(name);\n          })\n      );\n    })\n    .then(() => {\n      console.log('[SW] Claiming clients');\n      return self.clients.claim();\n    })\n  );\n});\n\n// ===== معالجة الطلبات =====\nself.addEventListener('fetch', event => {\n  const request = event.request;\n  \n  // تخطي طلبات غير GET\n  if (request.method !== 'GET') return;\n\n  // معالجة طلبات API\n  if (isApiRequest(request)) {\n    event.respondWith(handleApiRequest(request));\n    return;\n  }\n\n  // معالجة الملفات الثابتة\n  event.respondWith(\n    caches.match(request)\n      .then(cached => cached || fetchAndCache(request))\n      .catch(() => fallbackResponse(request))\n  );\n});\n\n// ===== دوال مساعدة =====\nfunction isApiRequest(request) {\n  return request.url.includes('newsapi.org') || \n         request.url.includes('disease.sh') ||\n         request.url.includes('gnews.io');\n}\n\nasync function handleApiRequest(request) {\n  try {\n    // تحويل HTTP إلى HTTPS\n    const secureRequest = request.url.startsWith('http:') ?\n      new Request(request.url.replace('http://', 'https://'), request) :\n      request;\n    \n    const response = await fetch(secureRequest);\n    \n    if (response.ok) {\n      const cache = await caches.open(API_CACHE_NAME);\n      await cache.put(request, response.clone());\n    }\n    return response;\n  } catch (err) {\n    console.error('[SW] API request failed:', err);\n    const cached = await caches.match(request);\n    return cached || apiErrorResponse();\n  }\n}\n\nasync function fetchAndCache(request) {\n  try {\n    const response = await fetch(request);\n    if (response.ok) {\n      const cache = await caches.open(CACHE_NAME);\n      await cache.put(request, response.clone());\n    }\n    return response;\n  } catch (err) {\n    console.error('[SW] Fetch failed:', err);\n    throw err;\n  }\n}\n\nfunction fallbackResponse(request) {\n  if (request.mode === 'navigate') {\n    return caches.match(OFFLINE_URL) || \n           offlinePageResponse();\n  }\n  return offlineDataResponse();\n}\n\nfunction apiErrorResponse() {\n  return new Response(\n    JSON.stringify({ error: 'Network error' }),\n    { status: 503, headers: { 'Content-Type': 'application/json' }}\n  );\n}\n\nfunction offlinePageResponse() {\n  return new Response(\n    '<h1>Offline</h1><p>You are currently offline</p>',\n    { headers: { 'Content-Type': 'text/html' }}\n  );\n}\n\nfunction offlineDataResponse() {\n  return new Response('Offline', { status: 503 });\n}\n\n// ===== معالجة الرسائل =====\nself.addEventListener('message', event => {\n  if (event.data === 'skipWaiting') {\n    console.log('[SW] Skipping waiting');\n    self.skipWaiting();\n  }\n});"],"names":["modules","entry","mainEntry","parcelRequireName","externals","distDir","publicUrl","devServer","globalObject","globalThis","self","window","global","previousRequire","importMap","i","cache","nodeRequire","module","require","bind","newRequire","name","jumped","currentRequire","err","Error","code","localRequire","resolve","x","id","Module","call","exports","res","isParcelRequire","moduleName","bundle","parent","register","Object","defineProperty","get","length","mainExports","define","amd","__globalThis","CACHE_NAME","API_CACHE_NAME","CACHE_URLS","handleApiRequest","request","secureRequest","url","startsWith","Request","replace","response","fetch","ok","caches","open","put","clone","console","error","cached","match","Response","JSON","stringify","status","headers","fetchAndCache","addEventListener","event","waitUntil","then","log","Promise","all","map","credentials","redirect","mode","type","warn","catch","skipWaiting","keys","cacheNames","filter","delete","clients","claim","method","includes","respondWith","data"],"version":3,"file":"sw.eba3f849.js.map"}